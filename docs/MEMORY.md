# Zonix 操作系统内存布局

本文档详细描述了 Zonix 操作系统的物理内存和虚拟内存布局。

---

## 目录

1. [概述](#1-概述)
2. [物理内存布局](#2-物理内存布局)
3. [虚拟内存布局](#3-虚拟内存布局)
4. [地址空间映射](#4-地址空间映射)
5. [页表结构](#5-页表结构)
6. [内存初始化流程](#6-内存初始化流程)
7. [关键地址和常量](#7-关键地址和常量)

---

## 1. 概述

### 1.1 基本参数

- **架构**: x86 (IA-32)
- **地址空间**: 32 位（4GB）
- **分页大小**: 4KB (4096 字节)
- **页表层级**: 2 级（页目录 + 页表）
- **内核基址**: 0xC0000000 (3GB)

### 1.2 内存管理特点

- **内核高端映射**: 内核位于虚拟地址空间的高 1GB (3GB-4GB)
- **线性映射**: 物理内存 0-896MB 线性映射到虚拟地址 0xC0000000-0xF8000000
- **分页机制**: 使用二级页表结构
- **物理内存管理**: 基于页面描述符数组（PageDesc）

### 1.3 为什么内核虚拟地址在 0xC0000000 而不是 0？

这是一个经过深思熟虑的设计决策，主要基于以下原因：

#### 1. **内核/用户地址空间分离**
将 4GB 虚拟地址空间分为两部分：
- **0x00000000 - 0xBFFFFFFF (0-3GB)**: 用户空间（每个进程独立）
- **0xC0000000 - 0xFFFFFFFF (3GB-4GB)**: 内核空间（所有进程共享）

**关键优势**：
- 每个用户进程拥有完整的 3GB 独立地址空间
- 所有进程共享同一个内核映射，节省内存
- 系统调用时无需切换页表（CR3），避免 TLB 刷新开销

#### 2. **NULL 指针保护**
如果内核从 0 开始，NULL 指针（0x00000000）可能意外访问内核数据：
```c
char *ptr = NULL;
*ptr = 'A';  // 如果内核在 0，可能写入内核！
```

将内核放在高地址后，虚拟地址 0 不映射，NULL 指针访问会立即触发缺页异常：
```c
char *ptr = NULL;
*ptr = 'A';  // Page Fault! 立即发现 bug
```

#### 3. **简化地址转换**
内核在 0xC0000000 使得物理/虚拟地址转换变成简单的加减法：
```c
// 物理 → 虚拟
#define K_ADDR(pa)  ((void *)((pa) + 0xC0000000))

// 虚拟 → 物理
#define P_ADDR(kva) ((uintptr_t)(kva) - 0xC0000000)
```

这种线性映射使得内核可以直接访问所有物理内存（前 896MB），无需复杂的映射表。

#### 4. **最小化系统调用开销**
当用户程序通过 `int 0x80` 或 `syscall` 进入内核时：

**内核在 3GB（Zonix 方案）**：
```
用户态 (CPL=3) → 内核态 (CPL=0)
    ↓
保持同一页表（CR3 不变）
    ↓
直接访问 0xC0000000+ 的内核代码
    ↓
TLB 保持有效，性能高效
```

**如果内核从 0 开始（不推荐）**：
```
用户态 (CPL=3) → 内核态 (CPL=0)
    ↓
必须切换页表（修改 CR3）
    ↓
TLB 全部失效（数百个周期延迟）
    ↓
内核代码执行
    ↓
再次切换页表返回用户态
    ↓
TLB 再次失效（性能损失巨大）
```

#### 5. **遵循行业标准**
- **Linux x86-32**: 3GB/1GB 分割（可配置为 2GB/2GB）
- **Windows**: 2GB/2GB 分割（可配置为 3GB/1GB）
- **BSD 系列**: 3GB/1GB 分割

采用 3GB 边界是 x86 架构上的事实标准，便于：
- 工具兼容（GDB、Valgrind 等可识别内核地址）
- 代码移植（用户态程序期望从 0 地址开始）
- 开发经验共享

#### 6. **支持多个用户进程**

**内核在 3GB 的进程布局**：
```
进程 A 页表：                进程 B 页表：
0x00000000 - 进程 A 代码    0x00000000 - 进程 B 代码
0x08000000 - 进程 A 堆      0x08000000 - 进程 B 堆
0xBFFFFFFF - 进程 A 栈      0xBFFFFFFF - 进程 B 栈
------------ 3GB 边界 ------------ 3GB 边界 ------------
0xC0000000 - 内核代码（共享）0xC0000000 - 内核代码（共享）
0xFFFFFFFF                  0xFFFFFFFF
```

每个进程的低 3GB 完全独立，高 1GB 指向同一个内核，完美隔离。

#### 7. **3GB 而非其他值的原因**
- **1GB (0x40000000)**: 用户空间太小，无法运行大型程序
- **2GB (0x80000000)**: 用户空间仍然受限（32 位数据库、科学计算）
- **3GB (0xC0000000)**: ✅ 平衡点，用户 3GB 足够大，内核 1GB 也够用
- **3.5GB**: 内核空间太小（512MB），大型服务器内核数据结构受限

**结论**：0xC0000000 是经过实践检验的最优选择，在用户空间大小和内核功能之间取得完美平衡。

---

## 2. 物理内存布局

### 2.1 完整物理内存映射图

```
物理地址空间 (Physical Memory)
+==================================+ 0xFFFFFFFF (4GB)
|                                  |
|        未使用区域                 |
|     (取决于实际物理内存大小)      |
|                                  |
+----------------------------------+ 0x02000000 (32MB)
|                                  |
|     扩展内存区 (Extended Memory) |
|        可用 RAM                  |
|                                  |
|  +--------------------------+    |
|  | 内核数据段 (Kernel Data) |    |
|  | - PageDesc 数组          |    |
|  | - 动态分配的数据结构     |    |
|  +--------------------------+    |
|  |                          |    |
|  | 内核代码段 (Kernel Text) |    |
|  | - kern/                  |    |
|  | - include/               |    |
|  +--------------------------+    |
+----------------------------------+ 0x00100000 (1MB)
|     保留区 (Reserved)            |
|  - BIOS 扩展                     |
|  - 映射硬件                      |
+----------------------------------+ 0x000F0000 (960KB)
|     高端内存 (Upper Memory)      |
|  - 视频显存 (VGA)                |
|    0xB8000: CGA 文本模式缓冲区   |
|  - BIOS ROM                      |
+----------------------------------+ 0x000A0000 (640KB)
|                                  |
|   常规内存 (Conventional Memory) |
|                                  |
|  +--------------------------+    |
|  |   Bootloader 加载区      |    |
|  |   0x10000 (64KB)         |    |
|  +--------------------------+    |
|  |   E820 内存映射          |    |
|  |   0x8000 (32KB)          |    |
|  +--------------------------+    |
|  |   栈和数据区             |    |
|  +--------------------------+    |
|  |   引导扇区代码           |    |
|  |   0x7C00                 |    |
|  +--------------------------+    |
|  |   BIOS 数据区 (BDA)      |    |
|  |   0x0400 - 0x04FF        |    |
|  +--------------------------+    |
|  |   中断向量表 (IVT)       |    |
|  |   0x0000 - 0x03FF        |    |
+----------------------------------+ 0x00000000
```

### 2.2 关键物理内存区域

| 起始地址 | 结束地址 | 大小 | 用途 | 说明 |
|---------|---------|------|------|------|
| 0x00000000 | 0x000003FF | 1KB | 中断向量表 (IVT) | 实模式中断向量，256 个中断 × 4 字节 |
| 0x00000400 | 0x000004FF | 256B | BIOS 数据区 (BDA) | BIOS 运行时数据 |
| 0x00000500 | 0x00007BFF | ~30KB | 可用常规内存 | 早期可用于引导加载器 |
| 0x00007C00 | 0x00007DFF | 512B | 引导扇区 | MBR 加载位置 |
| 0x00008000 | 0x00008003 | 4B | E820 映射数量 | 内存映射项计数 |
| 0x00008004 | 0x0000FFFF | ~32KB | E820 内存映射 | BIOS 提供的内存布局 |
| 0x00010000 | 0x0001FFFF | 64KB | 内核加载缓冲区 | Bootloader 加载 ELF 头 |
| 0x000A0000 | 0x000BFFFF | 128KB | 视频内存 | VGA 显存（0xB8000 文本模式） |
| 0x000C0000 | 0x000FFFFF | 256KB | BIOS ROM | BIOS 代码和数据 |
| 0x00100000 | ... | 变化 | 内核镜像 | ELF 内核加载位置 |
| KERNEL_END | ... | 变化 | PageDesc 数组 | 页面描述符数组（每页 16 字节） |
| ... | 最大物理内存 | 变化 | 可用 RAM | 由物理内存管理器管理 |

### 2.3 E820 内存映射

Zonix 在启动时从 BIOS 获取 E820 内存映射，存储在物理地址 0x8000：

```c
struct e820map {
    int nr_map;                     // 映射项数量 (0x8000)
    struct {
        uint64_t addr;              // 起始地址 (0x8004+)
        uint64_t size;              // 大小
        uint32_t type;              // 类型
    } map[E820MAX];                 // 最多 20 项
};

// 内存类型
#define E820_RAM      1             // 可用 RAM
#define E820_RESERVED 2             // 保留区域
#define E820_ACPI     3             // ACPI 可回收
#define E820_NVS      4             // ACPI NVS（不可回收）
```

---

## 3. 虚拟内存布局

### 3.1 完整虚拟地址空间映射图 (32位)

```
虚拟地址空间 (Virtual Memory)
+==================================+ 0xFFFFFFFF (4GB)
|                                  |
|      页表自映射区域               |
|   (Recursive Page Table Mapping) |
|                                  |
+----------------------------------+ 0xFAC00000 (VPT)
|                                  |
|     内核动态内存区                |
|  - 动态分配的内核数据结构         |
|  - 设备驱动缓冲区                |
|                                  |
+----------------------------------+ 0xF8000000
|                                  |
|     物理内存直接映射区            |
|     (Direct Physical Mapping)    |
|                                  |
|  物理地址 = 虚拟地址 - 0xC0000000|
|                                  |
|  +--------------------------+    |
|  |   内核数据段             |    |
|  |   - PageDesc 数组        |    |
|  |   - BSS 段               |    |
|  +--------------------------+    |
|  |   内核代码段             |    |
|  |   - .text                |    |
|  |   - .rodata              |    |
|  |   - .data                |    |
|  +--------------------------+    |
|                                  |
+----------------------------------+ 0xC0000000 (KERNEL_BASE, 3GB)
|                                  |
|                                  |
|       用户地址空间                |
|     (User Space, 3GB)            |
|                                  |
|  +--------------------------+    |
|  |   用户栈 (User Stack)    |    |
|  |      ↓ (向下增长)        |    |
|  +--------------------------+    |
|  |                          |    |
|  |   空闲区域               |    |
|  |                          |    |
|  +--------------------------+    |
|  |   堆 (Heap)              |    |
|  |      ↑ (向上增长)        |    |
|  +--------------------------+    |
|  |   BSS 段 (未初始化数据)  |    |
|  +--------------------------+    |
|  |   数据段 (Data)          |    |
|  +--------------------------+    |
|  |   代码段 (Text)          |    |
|  +--------------------------+    |
|                                  |
+----------------------------------+ 0x00000000
```

### 3.2 内核虚拟地址空间详解

| 起始地址 | 结束地址 | 大小 | 用途 | 权限 |
|---------|---------|------|------|------|
| 0xC0000000 | 0xC0100000 | 1MB | 内核代码和数据 (低端 1MB) | RW-, Kernel |
| 0xC0100000 | ~0xF8000000 | ~896MB | 物理内存线性映射区 | RW-, Kernel |
| 0xF8000000 | 0xFAC00000 | ~44MB | 内核动态内存/保留 | RW-, Kernel |
| 0xFAC00000 | 0xFB000000 | 4MB | 页表自映射区 (VPT) | RW-, Kernel |
| 0xFB000000 | 0xFFFFFFFF | ~80MB | 保留/未使用 | - |

### 3.3 用户虚拟地址空间（保留，未完全实现）

| 地址范围 | 典型用途 |
|---------|---------|
| 0x00000000 - 0x08048000 | 保留（NULL 指针保护） |
| 0x08048000 - ... | 用户程序代码段 (.text) |
| ... | 用户程序数据段 (.data, .bss) |
| ... | 堆 (heap)，向上增长 |
| 0xBFFFFFFF - ... | 用户栈 (stack)，向下增长 |

---

## 4. 地址空间映射

### 4.1 内核地址映射关系

**核心映射公式**:

```c
// 物理地址 → 内核虚拟地址
#define KERNEL_BASE     0xC0000000
#define K_ADDR(pa)      ((void *)((uintptr_t)(pa) + KERNEL_BASE))

// 内核虚拟地址 → 物理地址
#define P_ADDR(kva)     ((uintptr_t)(kva) - KERNEL_BASE)

// 示例：
// 物理地址 0x00100000 → 虚拟地址 0xC0100000
// 虚拟地址 0xC0200000 → 物理地址 0x00200000
```

### 4.2 地址映射示例

```
物理地址              虚拟地址                 说明
--------------------------------------------------------------
0x00000000    <-->   (不映射)                NULL 保护
0x00100000    <-->   0xC0100000             内核代码起始
0x00200000    <-->   0xC0200000             内核数据
0x01000000    <-->   0xC1000000             16MB 处
0x10000000    <-->   0xD0000000             256MB 处
0x38000000    <-->   0xF8000000             896MB 处 (映射上限)
```

### 4.3 特殊映射：页表自映射 (Recursive Mapping)

Zonix 使用页表自映射技术，使得页表本身可以像普通内存一样访问：

```
虚拟地址 0xFAC00000 (VPT) 映射到页目录自身

访问页表项的公式：
PTE 地址 = VPT + (PDX << 12) + (PTX << 2)

访问页目录项的公式：
PDE 地址 = VPT + (PDX(VPT) << 12) + (PDX << 2)
```

**实现代码** (`kern/mm/vmm.c`):
```c
pte_t *const vpt = (pte_t *)VPT;                          // 0xFAC00000
pde_t *const vpd = (pde_t *)PG_ADDR(PDX(VPT), PDX(VPT), 0);

// 初始化：将页目录的最后一项指向自己
boot_pgdir[PDX(VPT)] = P_ADDR(boot_pgdir) | PTE_P | PTE_W;
```

**作用**:
- 无需单独的数据结构跟踪页表
- 可以通过虚拟地址直接读写页表
- 简化页表管理代码

---

## 5. 页表结构

### 5.1 二级页表结构

Zonix 使用 x86 的二级页表结构：

```
虚拟地址 (32 位)
+----------+----------+------------+
|   PDX    |   PTX    |   Offset   |
+----------+----------+------------+
  10 位      10 位       12 位

虚拟地址分解：
- PDX (Page Directory Index):  虚拟地址 [31:22]，页目录索引 (0-1023)
- PTX (Page Table Index):       虚拟地址 [21:12]，页表索引 (0-1023)
- Offset:                        虚拟地址 [11:0]，页内偏移 (0-4095)
```

### 5.2 页表项格式

**页目录项 (PDE) 和页表项 (PTE) 格式**:

```
 31                                    12 11  9 8 7 6 5 4 3 2 1 0
+---------------------------------------+-----+-+-+-+-+-+-+-+-+-+
|     物理页框号 / 页表地址 (20 位)      | AVL |G|S|0|A|C|W|U|R|P|
+---------------------------------------+-----+-+-+-+-+-+-+-+-+-+
```

**标志位说明**:

| 位 | 名称 | 说明 |
|----|------|------|
| 0 | P (Present) | 1=页面在内存中，0=不在（可能在交换空间） |
| 1 | R/W (Read/Write) | 1=可读写，0=只读 |
| 2 | U/S (User/Supervisor) | 1=用户态可访问，0=仅内核态 |
| 3 | PWT (Write-Through) | 缓存策略：直写 |
| 4 | PCD (Cache Disable) | 1=禁用缓存 |
| 5 | A (Accessed) | CPU 自动设置，页面被访问 |
| 6 | D (Dirty) | CPU 自动设置，页面被写入（仅 PTE） |
| 7 | PS (Page Size) | 1=4MB 大页，0=4KB（仅 PDE） |
| 8 | G (Global) | 1=全局页，TLB 不刷新 |
| 9-11 | AVL (Available) | 操作系统可用位 |
| 12-31 | 地址 | 页框物理地址（4KB 对齐，低 12 位为 0） |

**常用宏定义** (`include/arch/x86/asm/pg.h`):

```c
#define PTE_P       0x001   // Present
#define PTE_W       0x002   // Writable
#define PTE_U       0x004   // User
#define PTE_PWT     0x008   // Write-Through
#define PTE_PCD     0x010   // Cache Disable
#define PTE_A       0x020   // Accessed
#define PTE_D       0x040   // Dirty
#define PTE_PS      0x080   // Page Size (4MB)
#define PTE_G       0x100   // Global

// 组合权限
#define PTE_USER    (PTE_P | PTE_W | PTE_U)  // 用户页面
#define PTE_KERN    (PTE_P | PTE_W)          // 内核页面
```

### 5.3 页表层次结构图

```
CR3 寄存器
    |
    v
+-------------------+
| 页目录 (Page Dir) |  1024 个 PDE (4KB)
+-------------------+
    |    |    |
    |    |    +---> 页表 1023
    |    +--------> 页表 1
    +-------------> 页表 0
                        |
                        v
                    +----------------+
                    | 页表 (PT)      |  1024 个 PTE (4KB)
                    +----------------+
                        |    |    |
                        |    |    +---> 物理页 1023
                        |    +--------> 物理页 1
                        +-------------> 物理页 0
                                            |
                                            v
                                        +------------+
                                        | 物理页面   |  4KB
                                        +------------+
```

**地址转换过程**:

1. CPU 从 CR3 寄存器获取页目录物理地址
2. 使用虚拟地址的 PDX (高 10 位) 索引页目录，得到页表地址
3. 使用虚拟地址的 PTX (中 10 位) 索引页表，得到物理页框号
4. 使用虚拟地址的 Offset (低 12 位) 作为页内偏移
5. 物理地址 = (页框号 << 12) + 偏移

---

## 6. 内存初始化流程

### 6.1 启动阶段内存状态变化

```
阶段 1: BIOS 启动 (实模式)
+------------------+
| MBR 加载到 0x7C00|
+------------------+
         |
         v
阶段 2: Bootloader 第一阶段 (实模式)
+------------------+
| 读取 E820 内存映射|
| 加载 bootloader  |
+------------------+
         |
         v
阶段 3: Bootloader 第二阶段 (实模式)
+------------------+
| 加载 ELF 内核到  |
| 0x10000 (64KB)   |
+------------------+
         |
         v
阶段 4: 进入保护模式 (head.S)
+------------------+
| 设置临时页表     |
| 启用分页         |
| CR3 = __boot_pgdir|
+------------------+
         |
         v
阶段 5: 内核初始化 (kern_init)
+------------------+
| 初始化物理内存   |
| 初始化虚拟内存   |
| 初始化交换系统   |
+------------------+
         |
         v
阶段 6: 运行时 (正常运行)
+------------------+
| 动态内存分配     |
| 页面换入换出     |
+------------------+
```

### 6.2 物理内存初始化详细流程

**入口函数**: `pmm_init()` (`kern/mm/pmm.c`)

```c
void pmm_init() {
    // 1. 初始化物理内存管理器
    pmm_mgr_init();           // 选择并初始化分配器（如 firstfit_pmm_mgr）
    
    // 2. 初始化页面数组
    page_init();              // 根据 E820 映射初始化 PageDesc 数组
}
```

**详细步骤**:

```
1. 读取 E820 内存映射
   ├── 遍历 E820 表，找出最大物理地址
   └── 计算需要的页面数量: npage = max_pa / 4KB

2. 分配 PageDesc 数组
   ├── 位置：紧跟在内核代码后 (KERNEL_END)
   ├── 大小：npage × sizeof(PageDesc) = npage × 16 字节
   └── 对齐到 4KB 边界

3. 标记所有页面为保留
   └── 初始状态：所有页面 flags = PG_RESERVED

4. 释放可用内存区域
   ├── 再次遍历 E820 表
   ├── 对于每个 RAM 区域：
   │   ├── 跳过内核和 PageDesc 数组占用的区域
   │   ├── 调用 pmm_mgr->init_memmap() 初始化页面
   │   └── 将页面加入空闲链表
   └── 打印内存映射信息

示例输出：
Memory Map: [0xc0234000, 0xc0800000], total=1484
```

### 6.3 虚拟内存初始化详细流程

**入口函数**: `vmm_init()` (`kern/mm/vmm.c`)

```c
void vmm_init() {
    // 1. 设置页表自映射
    boot_pgdir[PDX(VPT)] = P_ADDR(boot_pgdir) | PTE_P | PTE_W;
    
    // 2. 建立内核虚拟地址到物理地址的映射
    pgdir_init(boot_pgdir, KERNEL_BASE, KERNEL_MEM_SIZE, 0, PTE_W);
    //        页目录       虚拟地址起始  大小(896MB)     物理起始  权限
    
    // 3. 初始化 mm_struct
    mm_init(&init_mm);
    init_mm.pgdir = boot_pgdir;
}
```

**映射详情**:

```
虚拟地址范围                     物理地址范围               大小
0xC0000000 - 0xF8000000  <-->   0x00000000 - 0x38000000   896MB

页表项数量：
- 页目录项: 896MB / 4MB = 224 项
- 每个页目录项: 1024 个页表项
- 总页表项: 224 × 1024 = 229,376 项
```

---

## 7. 关键地址和常量

### 7.1 内存常量定义

**文件**: `include/arch/x86/asm/seg.h`, `include/arch/x86/asm/pg.h`

```c
// 地址常量
#define KERNEL_BASE     0xC0000000      // 内核虚拟地址基址 (3GB)
#define KERNEL_HEADER   0x00010000      // 内核加载缓冲区 (64KB)
#define KERNEL_MEM_SIZE 0x38000000      // 内核映射大小 (896MB)

#define E820_MEM_BASE   0x00008000      // E820 映射存储位置
#define E820_MEM_DATA   0x00008004      // E820 映射数据起始

#define VPT             0xFAC00000      // 页表虚拟地址

// 页面大小
#define PG_SIZE         4096            // 页面大小 (4KB)
#define PG_SHIFT        12              // 页面位移

// 页表参数
#define PDE_NUM         1024            // 页目录项数量
#define PTE_NUM         1024            // 页表项数量
#define PT_SIZE         (PG_SIZE * PTE_NUM)  // 页表覆盖范围 (4MB)

// 段选择子
#define GD_KTEXT        0x08            // 内核代码段
#define GD_KDATA        0x10            // 内核数据段
#define GD_UTEXT        0x18            // 用户代码段
#define GD_UDATA        0x20            // 用户数据段
```

### 7.2 地址转换宏

```c
// 虚拟地址分解
#define PDX(va)     (((uintptr_t)(va) >> 22) & 0x3FF)  // 页目录索引
#define PTX(va)     (((uintptr_t)(va) >> 12) & 0x3FF)  // 页表索引
#define PGOFF(va)   ((uintptr_t)(va) & 0xFFF)          // 页内偏移

// 地址提取
#define PTE_ADDR(pte)  ((uintptr_t)(pte) & ~0xFFF)     // PTE 中的物理地址
#define PDE_ADDR(pde)  PTE_ADDR(pde)                   // PDE 中的页表地址

// 地址构造
#define PG_ADDR(d, t, o)  ((uintptr_t)((d) << 22 | (t) << 12 | (o)))

// 物理/虚拟地址转换
#define P_ADDR(kva)  ((uintptr_t)(kva) - KERNEL_BASE)  // 虚拟 → 物理
#define K_ADDR(pa)   ((void *)((uintptr_t)(pa) + KERNEL_BASE))  // 物理 → 虚拟

// 页面对齐
#define ROUND_DOWN(a, n)  (((uintptr_t)(a)) & ~((n) - 1))
#define ROUND_UP(a, n)    ROUND_DOWN((uintptr_t)(a) + (n) - 1, (n))
```

### 7.3 页面数量计算

```c
// 页面数量宏
#define PAG_NUM(addr)  ((addr) >> PG_SHIFT)  // 地址 → 页号

// 示例：
// 32MB 物理内存 = 0x02000000 字节
// 页面数量 = 0x02000000 >> 12 = 8192 页
// PageDesc 数组大小 = 8192 × 16 字节 = 128KB
```

---

## 8. 内存使用示例

### 8.1 分配物理页面

```c
// 分配 1 个物理页面
PageDesc *page = alloc_pages(1);
if (page == NULL) {
    panic("Out of memory");
}

// 获取物理地址
uintptr_t pa = page2pa(page);           // 例如: 0x01000000

// 获取内核虚拟地址
void *kva = page2kva(page);             // 例如: 0xC1000000
```

### 8.2 创建页表映射

```c
// 为虚拟地址 0x200000 创建映射
uintptr_t va = 0x200000;
uint32_t perm = PTE_P | PTE_W | PTE_U;  // 用户态，可读写

// 方法 1: 手动分配页面并映射
PageDesc *page = alloc_pages(1);
page_insert(boot_pgdir, page, va, perm);

// 方法 2: 自动分配并映射
PageDesc *page = pgdir_alloc_page(boot_pgdir, va, perm);
```

### 8.3 访问页表项

```c
// 获取虚拟地址 va 的页表项
uintptr_t va = 0xC0123456;
pte_t *ptep = get_pte(boot_pgdir, va, 0);  // 0=不创建

if (ptep && (*ptep & PTE_P)) {
    // 页面存在
    uintptr_t pa = PTE_ADDR(*ptep);        // 提取物理地址
    int writable = (*ptep & PTE_W) != 0;
    int user = (*ptep & PTE_U) != 0;
} else {
    // 页面不存在或已换出
}
```

### 8.4 地址转换示例

```c
// 示例 1: 访问物理地址 0x100000 处的数据
uintptr_t pa = 0x100000;
void *kva = K_ADDR(pa);                    // = 0xC0100000
uint32_t *data = (uint32_t *)kva;
*data = 0x12345678;                        // 写入数据

// 示例 2: 将内核虚拟地址转换为物理地址
void *kernel_ptr = &some_kernel_variable;  // 例如 0xC0200000
uintptr_t pa = P_ADDR(kernel_ptr);         // = 0x00200000
```

---

## 9. 内存布局总结

### 9.1 内存分配策略

| 类型 | 策略 | 特点 |
|------|------|------|
| 物理内存 | First Fit / Buddy System | 简单高效，适合小规模系统 |
| 虚拟内存 | 按需分配 | 支持页面换入换出 |
| 内核空间 | 静态 + 动态 | 启动时映射，运行时可扩展 |
| 用户空间 | 动态分配 | 进程独立地址空间 |

### 9.2 内存保护机制

1. **分页保护**: 使用页表标志位控制访问权限
2. **内核/用户分离**: 用户态无法访问内核空间 (U/S 位)
3. **只读保护**: 代码段标记为只读 (W 位清除)
4. **NULL 指针保护**: 虚拟地址 0 不映射，访问会触发缺页异常

### 9.3 性能优化

1. **TLB (Translation Lookaside Buffer)**: 缓存页表项
2. **页表自映射**: 减少页表访问开销
3. **大页支持**: 可选 4MB 页面减少 TLB 未命中
4. **局部性原理**: 内核线性映射利用缓存局部性

---

## 10. 调试和工具

### 10.1 打印页表信息

```bash
# 在 Zonix shell 中执行
zonix> pgdir

# 输出示例：
-------------------- BEGIN --------------------
PDE(001) 00000000-00400000 00400000 urw
  |-- PTE(00100) 00000000-00100000 00100000 -rw
  |-- PTE(00001) 000b8000-000b9000 00001000 urw
PDE(224) c0000000-f8000000 38000000 -rw
  |-- PTE(00100) c0000000-c0100000 00100000 -rw
  |-- PTE(0036c) c0100000-c0468000 00368000 -rw
--------------------- END ---------------------
```

### 10.2 内存统计

```c
// 获取空闲页面数量
size_t free_pages = pmm_mgr->nr_free_pages();
cprintf("Free memory: %d pages (%d KB)\n", 
        free_pages, free_pages * 4);
```

### 10.3 使用 GDB 调试内存

```bash
# 启动 GDB 调试
make debug

# 在 GDB 中查看内存
(gdb) x/16x 0xC0100000     # 查看虚拟地址
(gdb) x/16x 0x100000       # 查看物理地址（需设置 CR3）
(gdb) info registers cr3   # 查看页目录地址
(gdb) monitor info tlb     # 查看 TLB（QEMU）
```

---

## 附录

### A. 完整的启动序列

```
1. BIOS 加载 MBR → 0x7C00
   ├── 实模式 16 位
   └── 512 字节 bootloader

2. MBR 加载 bootloader → 0x7E00
   ├── 切换到保护模式
   └── 读取 E820 内存映射

3. Bootloader 加载内核 → 0x10000
   ├── 读取 ELF 文件
   └── 解析程序头，加载到指定位置

4. 跳转到 head.S (_main)
   ├── 加载 GDT
   ├── 加载 IDT
   ├── 设置临时页表 (__boot_pgdir)
   ├── 启用分页 (CR0.PG = 1)
   └── 跳转到高地址 (0xC0XXXXXX)

5. 执行 kern_init()
   ├── 初始化控制台
   ├── 初始化物理内存 (pmm_init)
   ├── 初始化虚拟内存 (vmm_init)
   ├── 初始化中断 (idt_init)
   ├── 初始化设备驱动
   └── 启动 shell
```

### B. 相关文件索引

| 文件路径 | 说明 |
|---------|------|
| `include/arch/x86/asm/seg.h` | 段定义和内存布局常量 |
| `include/arch/x86/asm/pg.h` | 分页相关常量和宏 |
| `include/arch/x86/mmu.h` | MMU 相关宏和地址转换 |
| `kern/mm/pmm.c` | 物理内存管理实现 |
| `kern/mm/vmm.c` | 虚拟内存管理实现 |
| `kern/mm/swap.c` | 页面交换实现 |
| `init/head.S` | 启动汇编代码 |
| `boot/bootload.c` | Bootloader 实现 |

### C. 参考资料

1. **Intel x86 手册**: Intel® 64 and IA-32 Architectures Software Developer's Manual Volume 3A (System Programming Guide)
2. **x86 内存管理**: Chapter 3 - Protected-Mode Memory Management
3. **分页机制**: Chapter 4 - Paging
4. **MIT xv6**: 经典教学操作系统，类似的内存布局设计

---

**文档版本**: v1.0  
**创建日期**: 2025-10-17  
**作者**: Zonix 开发团队  
**最后更新**: 2025-10-17
